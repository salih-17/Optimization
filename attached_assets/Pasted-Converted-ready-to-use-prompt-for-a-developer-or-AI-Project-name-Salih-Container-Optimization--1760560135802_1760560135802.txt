Converted — ready-to-use prompt (for a developer or AI)
Project name: Salih Container Optimization
Goal (short): Build a Python-backed web application with a polished professional frontend that lets users upload a CSV of product data, edit optimization variables/constraints on a second screen, run an uploaded Python optimizer, and produce a printable results report.
Requirements — functional
1.	Upload
o	Page: Upload CSV
o	Accepts a CSV with the same columns as the provided sample (SKU, Description, BoxLength_m, BoxWidth_m, BoxHeight_m, WeightPerBox_kg, AvailableStock, SalesPerDay, CoverageDays, ProfitPerBox, CostPerBox, MinShipQty, etc.).
o	Validate file and show parsing errors if present.
2.	Review & Edit Variables
o	Page: Configuration
o	Show parsed CSV as an editable table.
o	Show global variables at top (editable):
	CONTAINER_VOLUME_M3 (default 33.0)
	CONTAINER_MAX_WEIGHT_KG (default 26000.0)
	AVAILABLE_BUDGET (default 20000)
	GLOBAL_LEAD_TIME_DAYS (default 30)
	Score weights (w_profit, w_density, w_velocity — defaults 0.3, 0.6, 0.1)
o	Allow editing of per-row fields (e.g., MinShipQty, CoverageDays, SalesPerDay, AvailableStock, CostPerBox, etc.)
o	Provide input validation (numeric ranges, required fields).
3.	Run Optimization
o	A Start button runs the provided Python script (the user will supply the script; assume it uses pandas & pulp as in the sample).
o	The backend should accept the edited data and variables, run the optimizer, and return results.
o	No FastAPI and no Docker. (Suggested: a lightweight Python web framework or GUI wrapper — see Implementation notes below.)
4.	Results & Report
o	Show a clean summary: solver status, total boxes selected, total volume used (and %), total weight used (and %), total cost vs budget, total profit, total score.
o	Show a results table of selected SKUs with qty, volume, weight, cost, score, OrderQty.
o	Provide a Download report button (PDF and CSV) and Print friendly view.
5.	UX / UI
o	Professional, minimal, responsive layout.
o	Two main flows: Upload → Configure → Run → Results.
o	Use clear labels, tooltips for variables, and validation messages.
o	Allow exporting the edited input table and final results.
Non-functional / constraints
•	Backend: Python (must integrate the provided script).
•	Do not use FastAPI or Docker.
•	The app must run locally or on a standard web host. (If a server framework is required, recommend alternatives in the implementation notes.)
•	Security: validate uploaded files, avoid arbitrary code execution from uploads.
•	Performance: handle CSVs of reasonable size (e.g., up to a few thousand rows).
Implementation notes / suggestions (pick one)
•	Option A — Desktop app: Use a Python GUI toolkit (PySide6 / PyQt / Toga / Tkinter) to wrap the script as a desktop application. Pros: easy local install, no web-server dependency.
•	Option B — Web app (no FastAPI): Use Flask (lightweight) or a WSGI framework (again, not FastAPI). Frontend can be React, Vue, or plain HTML/CSS with Bootstrap/Tailwind. The backend receives the edited CSV and variables via a POST request, runs the optimizer, and returns JSON results and a PDF render.
•	Option C — Electron + Python: Use an Electron frontend that communicates with a local Python process via REST or IPC, avoiding Docker.
Security & execution
•	Do not execute arbitrary uploaded Python code. If the user will supply a script, run only the provided optimizer logic or require the user to paste the function body into a restricted API call. Sanitize inputs and run the solver with resource limits.
Acceptance criteria
•	User can upload a CSV and edit both global and per-row variables.
•	Clicking Start runs the optimizer and returns correct results for the sample CSV (developer to confirm with the sample script).
•	Results page shows the required summaries and offers PDF/CSV export and print support.
•	The app runs without using FastAPI or Docker.
Deliverables
1.	Working application (source code) + README with run instructions.
2.	Example build using the sample CSV provided.
3.	Screenshots or short walkthrough GIF of full flow (upload → configure → run → results).
4.	Optional: Dockerfile removed by user request (do not include).
________________________________________
Short corrected sample description (one-paragraph) to include in project README
Salih Container Optimization is a Python-backed application that helps select product boxes to load into a container subject to volume, weight, and budget constraints. Users upload a CSV of product data, adjust global and per-item parameters on a configuration page, then run the optimizer to obtain an ordered list of SKUs to ship plus a printable report summarizing volumes, weights, costs, and scores. The application integrates the provided Python optimization script (which uses pandas and PuLP) and displays results in a user-friendly format.
________________________________________
If you want, I can now:
•	produce a UI mockup (wireframe) in HTML/CSS (single-file) that matches this prompt, or
•	rewrite the prompt for a specific implementation choice (Flask + React, or a PySide6 desktop app). Which implementation should I assume?
Python code to convert to function
import pandas as pd import pulp import numpy as np # ---------------- configirations ---------------- CONTAINER_VOLUME_M3 = 33.0 CONTAINER_MAX_WEIGHT_KG = 26000.0 AVAILABLE_BUDGET = 20000 GLOBAL_LEAD_TIME_DAYS = 30 w_profit, w_density, w_velocity = 0.3, 0.6, 0.1 df = pd.read_csv("products_with_cost.csv") for col in ["LeadTimeDays", "MinShipQty", "CoverageDays", "SalesPerDay", "AvailableStock"]: if col not in df.columns: if col == "LeadTimeDays": df[col] = GLOBAL_LEAD_TIME_DAYS else: df[col] = 0 # ---------------- some calulated columns ---------------- df["DemandDuringLeadTime"] = df["SalesPerDay"] * df["LeadTimeDays"] df["DemandDuringCoverage"] = df["SalesPerDay"] * df["CoverageDays"] df["TotalNeeded"] = df["DemandDuringLeadTime"] + df["DemandDuringCoverage"] df["OrderQty"] = (df["TotalNeeded"] - df["AvailableStock"]).clip(lower=0).astype(int) df["MaxShippable"] = df["OrderQty"] df["VolumePerBox_m3"] = df["BoxLength_m"] * df["BoxWidth_m"] * df["BoxHeight_m"] df["VolumePerBox_m3"] = df["VolumePerBox_m3"].replace(0, 1e-9) df["ProfitPerBox"] = df["ProfitPerBox"] df["ProfitPerCubicMeter"] = df["ProfitPerBox"] / df["VolumePerBox_m3"] # ---------------- Score Calculation ---------------- def norm_minmax(s): s = s.astype(float) mn, mx = s.min(), s.max() if np.isclose(mx, mn): return np.ones(len(s)) * 0.5 return (s - mn) / (mx - mn) df["n_profit"] = norm_minmax(df["ProfitPerBox"]) df["n_density"] = norm_minmax(df["ProfitPerCubicMeter"]) df["n_velocity"] = norm_minmax(df["SalesPerDay"]) df["score"] = w_profit * df["n_profit"] + w_density * df["n_density"] + w_velocity * df["n_velocity"] # ---------------- Model Building ---------------- model1 = pulp.LpProblem("Stage1_Maximize_Profit", pulp.LpMaximize) # ---------------- Constraints ---------------- x_vars = {} for _, row in df.iterrows(): up = int(row["MaxShippable"]) var = pulp.LpVariable(f"x_{row['SKU']}", lowBound=0, upBound=up, cat="Integer") x_vars[row["SKU"]] = var y_vars = {} for _, row in df.iterrows(): y = pulp.LpVariable(f"y_{row['SKU']}", cat="Binary") y_vars[row["SKU"]] = y # x >= MinShipQty * y model1 += x_vars[row["SKU"]] >= int(row.get("MinShipQty", 0)) * y # x <= M * y model1 += x_vars[row["SKU"]] <= int(max(1, row["MaxShippable"])) * y model1 += pulp.lpSum([row["CostPerBox"] * x_vars[row["SKU"]] for _, row in df.iterrows()]) <= AVAILABLE_BUDGET model1 += pulp.lpSum( [row["VolumePerBox_m3"] * x_vars[row["SKU"]] for _ , row in df.iterrows()] ) <= CONTAINER_VOLUME_M3 model1 += pulp.lpSum([row["WeightPerBox_kg"] * x_vars[row["SKU"]] for _, row in df.iterrows()]) <= CONTAINER_MAX_WEIGHT_KG # Target model1 += pulp.lpSum([row["score"] * x_vars[row["SKU"]] for _, row in df.iterrows()]) # ---------- Solve ---------- solver = pulp.PULP_CBC_CMD(msg=0) model1.solve(solver) # ---------- Results ---------- selected = [] total_volume = total_weight = total_adjprofit = total_score = total_cost = 0 for _, row in df.iterrows(): sku = row["SKU"] qty = int(pulp.value(x_vars[sku]) or 0) if qty > 0: vol = row["VolumePerBox_m3"] * qty wt = row["WeightPerBox_kg"] * qty adjprofit = row["ProfitPerBox"] * qty score_val = row["score"] * qty cost = row["CostPerBox"] * qty selected.append({ "SKU": sku, "Quantity": qty, "Volume_m3": vol, "Weight_kg": wt, "AdjProfit": adjprofit, "Score": score_val, "Cost": cost, "OrderQty": int(row["OrderQty"]) }) total_volume += vol total_weight += wt total_adjprofit += adjprofit total_score += score_val total_cost += cost # ---------- Print summary ---------- print("Status:", pulp.LpStatus[model1.status]) print(f"Total boxes selected: {sum(it['Quantity'] for it in selected)}") print(f"Total volume used: {total_volume:.3f}/{CONTAINER_VOLUME_M3} m3 ({total_volume/CONTAINER_VOLUME_M3*100:.1f}%)") print(f"Total weight used: {total_weight:.1f}/{CONTAINER_MAX_WEIGHT_KG} kg ({total_weight/CONTAINER_MAX_WEIGHT_KG*100:.1f}%)") print(f"Total cost of selected boxes: {total_cost:.2f} (available budget: {AVAILABLE_BUDGET})") print(f"Total adjusted profit (sum ProfitPerBox): {total_adjprofit:.2f}") print(f"Total Score: {total_score:.3f}") print("\nSelected SKUs (qty, OrderQty):") for it in selected: print(f"{it['SKU']}: qty={it['Quantity']}, orderNeeded={it['OrderQty']}, vol={it['Volume_m3']:.3f} m3, cost={it['Cost']:.2f}, score={it['Score']:.3f}")
Data Template
SKU,Description,BoxLength_m,BoxWidth_m,BoxHeight_m,WeightPerBox_kg,AvailableStock,SalesPerDay,CoverageDays,ProfitPerBox,CostPerBox,MinShipQty SKU001,Green Tea Box,0.50,0.40,0.35,10,500,2.0,60,40,30,50 SKU002,Black Tea Box,0.60,0.40,0.45,12,400,1.5,60,45,35,40 SKU003,White Tea Pack,0.30,0.25,0.20,5,800,1.0,60,15,8,60 SKU004,Oolong Tea,0.45,0.40,0.30,9,300,0.8,60,30,20,30 SKU005,Matcha Powder,0.25,0.25,0.20,4,600,1.2,60,25,12,50 SKU006,Herbal Tea Mix,0.55,0.45,0.40,11,350,0.9,60,35,28,40 SKU007,Jasmine Tea,0.40,0.35,0.30,8,700,1.8,60,28,18,60 SKU008,Earl Grey Tea,0.50,0.45,0.40,10,200,0.6,60,32,22,20 SKU009,Chai Spice Blend,0.35,0.30,0.25,7,500,1.4,60,20,15,50 SKU010,Mint Tea,0.40,0.35,0.25,6,900,1.6,60,22,16,60 SKU011,Lemon Tea,0.30,0.25,0.20,5,750,1.1,60,18,10,50 SKU012,Detox Herbal Tea,0.45,0.35,0.30,8,400,1.0,60,27,19,40 SKU013,Berry Infusion,0.50,0.40,0.35,9,450,1.3,60,31,21,40 SKU014,Chamomile Tea,0.40,0.30,0.25,6,650,1.2,60,24,14,50 SKU015,Hibiscus Tea,0.35,0.35,0.25,7,550,1.5,60,26,16,50
